# FireFly Core Kubernetes Deployment
# This manifest creates:
# - ConfigMap with FireFly configuration
# - StatefulSet running FireFly Core
# - Service for internal access
# - Ingress for external access (optional)
#
# Environment variables required:
#   - ORG: Organization name (org1, org2)
#   - NAMESPACE: Kubernetes namespace
#   - FABCONNECT_HOST: FabConnect service hostname
#   - POSTGRES_URL: PostgreSQL connection string
#
# Usage:
#   export ORG=org1 NAMESPACE=org1 FABCONNECT_HOST=fabconnect-org1.org1.svc.cluster.local POSTGRES_URL="postgresql://postgres:postgres@postgres.org1.svc.cluster.local:5432/firefly"
#   cat kind/firefly/firefly-deployment.yaml | envsubst | kubectl apply -f -

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: firefly-${ORG}-config
  namespace: ${NAMESPACE}
  labels:
    app: firefly
    org: ${ORG}
data:
  # FireFly configuration
  config.json: |
    {
      "log": {
        "level": "debug"
      },
      "debug": {
        "port": 6060,
        "address": "0.0.0.0"
      },
      "http": {
        "address": "0.0.0.0",
        "port": 5000,
        "publicURL": "https://firefly-${ORG}.localho.st"
      },
      "admin": {
        "enabled": true,
        "port": 5001,
        "address": "0.0.0.0",
        "publicURL": "http://127.0.0.1:5001"
      },
      "spi": {
        "enabled": true,
        "port": 5001,
        "address": "0.0.0.0",
        "publicURL": "http://127.0.0.1:5001"
      },
      "ui": {
        "enabled": true,
        "path": "./frontend"
      },
      "event": {
        "dbevents": {
          "bufferSize": 10000
        }
      },
      "namespaces": {
        "default": "default",
        "predefined": [
          {
            "name": "default",
            "description": "Default namespace for ${ORG}",
            "plugins": [
              "database0",
              "blockchain0",
              "dataexchange0",
              "sharedstorage0"
            ],
            "multiparty": {
              "enabled": true,
              "org": {
                "name": "${ORG}",
                "key": "${ORG}user"
              },
              "node": {
                "name": "${ORG}_node_1"
              },
              "contract": [
                {
                  "location": {
                    "channel": "pm3",
                    "chaincode": "firefly-go"
                  },
                  "firstEvent": "0"
                }
              ]
            }
          }
        ]
      },
      "plugins": {
        "database": [
          {
            "name": "database0",
            "type": "postgres",
            "postgres": {
              "url": "${POSTGRES_URL}?sslmode=disable",
              "migrations": {
                "auto": true
              }
            }
          }
        ],
        "blockchain": [
          {
            "name": "blockchain0",
            "type": "fabric",
            "fabric": {
              "fabconnect": {
                "url": "http://${FABCONNECT_HOST}:3000",
                "signer": "${ORG}admin",
                "channel": "pm3",
                "chaincode": "firefly-go",
                "topic": "firefly-${ORG}"
              }
            }
          }
        ],
        "dataexchange": [
          {
            "name": "dataexchange0",
            "type": "ffdx",
            "ffdx": {
              "url": "http://dataexchange-${ORG}.${NAMESPACE}.svc.cluster.local:3000"
            }
          }
        ],
        "sharedstorage": [
          {
            "name": "sharedstorage0",
            "type": "ipfs",
            "ipfs": {
              "api": {
                "url": "http://ipfs-${ORG}-api.${NAMESPACE}.svc.cluster.local:5001"
              },
              "gateway": {
                "url": "http://ipfs-${ORG}-api.${NAMESPACE}.svc.cluster.local:8080"
              }
            }
          }
        ]
      }
    }

---
apiVersion: v1
kind: Service
metadata:
  name: firefly-${ORG}
  namespace: ${NAMESPACE}
  labels:
    app: firefly
    org: ${ORG}
spec:
  type: ClusterIP
  clusterIP: None
  selector:
    app: firefly
    org: ${ORG}
  ports:
  - name: api
    port: 5000
    targetPort: 5000
    protocol: TCP
  - name: admin
    port: 8080
    targetPort: 8080
    protocol: TCP

---
apiVersion: v1
kind: Service
metadata:
  name: firefly-${ORG}-api
  namespace: ${NAMESPACE}
  labels:
    app: firefly
    org: ${ORG}
spec:
  type: ClusterIP
  selector:
    app: firefly
    org: ${ORG}
  ports:
  - name: api
    port: 5000
    targetPort: 5000
    protocol: TCP

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: firefly-${ORG}
  namespace: ${NAMESPACE}
  labels:
    app: firefly
    org: ${ORG}
spec:
  serviceName: firefly-${ORG}
  replicas: 1
  selector:
    matchLabels:
      app: firefly
      org: ${ORG}
  template:
    metadata:
      labels:
        app: firefly
        org: ${ORG}
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: default
      securityContext:
        runAsNonRoot: false
        fsGroup: 1000

      initContainers:
      # Wait for PostgreSQL to be ready
      - name: wait-for-postgres
        image: curlimages/curl:7.85.0
        command:
          - sh
          - -c
          - |
            set -e
            echo "Waiting for PostgreSQL..."
            for i in $(seq 1 30); do
              if curl -s postgres:5432 >/dev/null 2>&1 || nc -zv postgres 5432 >/dev/null 2>&1; then
                echo "PostgreSQL is ready"
                exit 0
              fi
              echo "PostgreSQL not ready, retrying... ($i/30)"
              sleep 2
            done
            echo "PostgreSQL did not become ready, continuing anyway..."

      # Wait for FabConnect to be ready
      - name: wait-for-fabconnect
        image: curlimages/curl:7.85.0
        command:
          - sh
          - -c
          - |
            set -e
            echo "Waiting for FabConnect..."
            for i in $(seq 1 30); do
              if curl -s http://fabconnect-${ORG}:3000/api >/dev/null 2>&1; then
                echo "FabConnect is ready"
                exit 0
              fi
              echo "FabConnect not ready, retrying... ($i/30)"
              sleep 2
            done
            echo "FabConnect did not become ready, continuing anyway..."
        env:
        - name: ORG
          value: "${ORG}"

      containers:
      - name: firefly
        image: ghcr.io/hyperledger/firefly:v1.4.0
        imagePullPolicy: IfNotPresent
        ports:
        - name: api
          containerPort: 5000
          protocol: TCP
        - name: admin
          containerPort: 8080
          protocol: TCP

        # FireFly startup arguments
        args:
          - "-f"
          - "/etc/firefly/config/config.json"

        # Environment variables
        env:
        - name: FF_CONFIG_FILE
          value: /etc/firefly/config/config.json

        # Resource requests and limits
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"

        # Health checks
        livenessProbe:
          httpGet:
            path: /api
            port: api
          initialDelaySeconds: 60
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3

        readinessProbe:
          httpGet:
            path: /api
            port: api
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 2

        # Volume mounts
        volumeMounts:
        - name: config
          mountPath: /etc/firefly/config
          readOnly: true
        - name: data
          mountPath: /var/lib/firefly

      # Volumes
      volumes:
      - name: config
        configMap:
          name: firefly-${ORG}-config

  # Persistent volume for FireFly data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 5Gi

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: firefly-${ORG}
  namespace: ${NAMESPACE}
  labels:
    app: firefly
    org: ${ORG}
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-staging"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - firefly-${ORG}.localho.st
    secretName: firefly-${ORG}-tls
  rules:
  - host: firefly-${ORG}.localho.st
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: firefly-${ORG}-api
            port:
              number: 5000
