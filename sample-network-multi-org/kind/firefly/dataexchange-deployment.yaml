# FireFly Data Exchange HTTPS Deployment
# Enables peer-to-peer messaging between FireFly organizations
#
# Environment variables required:
#   - ORG: Organization name (org1, org2)
#   - NAMESPACE: Kubernetes namespace
#
# Usage:
#   export ORG=org1 NAMESPACE=org1
#   cat kind/firefly/dataexchange-deployment.yaml | envsubst | kubectl apply -f -

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: dataexchange-${ORG}-config
  namespace: ${NAMESPACE}
  labels:
    app: dataexchange
    org: ${ORG}
data:
  # DataExchange peer configuration script
  # This will be executed by an init job to configure peers after both orgs are running
  configure-peers.sh: |
    #!/bin/sh
    set -e
    
    # Determine which peer to add based on current org
    if [ "${ORG}" = "org1" ]; then
      PEER_ENDPOINT="https://dataexchange-org2.localho.st"
    elif [ "${ORG}" = "org2" ]; then
      PEER_ENDPOINT="https://dataexchange-org1.localho.st"
    else
      echo "Unknown org: ${ORG}"
      exit 1
    fi
    
    # Wait for local dataexchange to be ready
    echo "Waiting for DataExchange API to be ready..."
    for i in $(seq 1 30); do
      if wget -q -O- http://localhost:3000/api/v1/status 2>/dev/null; then
        echo "DataExchange is ready"
        break
      fi
      echo "Waiting... ($i/30)"
      sleep 2
    done
    
    # Add peer if not already configured
    echo "Checking if peer $PEER_ENDPOINT is already configured..."
    if wget -q -O- http://localhost:3000/api/v1/peers 2>/dev/null | grep -q "$PEER_ENDPOINT"; then
      echo "Peer already configured"
    else
      echo "Adding peer: $PEER_ENDPOINT"
      wget -q -O- --post-data="{\"endpoint\":\"$PEER_ENDPOINT\"}" \
        --header="Content-Type: application/json" \
        http://localhost:3000/api/v1/peers || true
      echo "Peer configuration complete"
    fi
  
  config.json: |
    {
      "api": {
        "hostname": "0.0.0.0",
        "port": 3000
      },
      "p2p": {
        "hostname": "0.0.0.0",
        "port": 3001,
        "endpoint": "https://dataexchange-${ORG}.localho.st"
      },
      "peers": []
    }

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: dataexchange-${ORG}-data
  namespace: ${NAMESPACE}
  labels:
    app: dataexchange
    org: ${ORG}
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dataexchange-${ORG}
  namespace: ${NAMESPACE}
  labels:
    app: dataexchange
    org: ${ORG}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dataexchange
      org: ${ORG}
  template:
    metadata:
      labels:
        app: dataexchange
        org: ${ORG}
    spec:
      initContainers:
      - name: generate-certs
        image: alpine/openssl:latest
        command:
        - sh
        - -c
        - |
          # Create required directories
          mkdir -p /data/destinations /data/peers /data/peer-certs /data/blobs
          
          # Generate certificates if they don't exist
          if [ ! -f /data/key.pem ]; then
            openssl req -new -x509 -nodes -days 365 \
              -subj "/CN=dataexchange-${ORG}/O=org-${ORG}" \
              -keyout /data/key.pem \
              -out /data/cert.pem
            chmod 644 /data/*.pem
            echo "Generated self-signed certificates"
          else
            echo "Certificates already exist"
          fi
        volumeMounts:
        - name: data
          mountPath: /data
      containers:
      - name: dataexchange
        image: ghcr.io/hyperledger/firefly-dataexchange-https:latest
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 3000
          protocol: TCP
        env:
        - name: PORT
          value: "3000"
        - name: LOG_LEVEL
          value: "info"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /api/v1/status
            port: http
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/v1/status
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: data
          mountPath: /data
        - name: config
          mountPath: /data/config.json
          subPath: config.json
          readOnly: true
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: dataexchange-${ORG}-data
      - name: config
        configMap:
          name: dataexchange-${ORG}-config

---
apiVersion: v1
kind: Service
metadata:
  name: dataexchange-${ORG}
  namespace: ${NAMESPACE}
  labels:
    app: dataexchange
    org: ${ORG}
spec:
  type: ClusterIP
  selector:
    app: dataexchange
    org: ${ORG}
  ports:
  - name: http
    port: 3000
    targetPort: 3000
    protocol: TCP

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: dataexchange-${ORG}
  namespace: ${NAMESPACE}
  labels:
    app: dataexchange
    org: ${ORG}
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-staging"
    nginx.ingress.kubernetes.io/proxy-body-size: "100m"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - dataexchange-${ORG}.localho.st
    secretName: dataexchange-${ORG}-tls
  rules:
  - host: dataexchange-${ORG}.localho.st
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: dataexchange-${ORG}
            port:
              number: 3000
